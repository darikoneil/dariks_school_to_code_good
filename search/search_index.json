{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"lessons/10_testing/integration_testing/","title":"Integration Testing","text":"<p>Integration tests verify that multiple components work together correctly.</p>"},{"location":"lessons/10_testing/integration_testing/#differences-from-unit-tests","title":"Differences from Unit Tests","text":"<ul> <li>Integration tests exercise interactions across modules or services.</li> <li>They are slower and require controlled environments.</li> </ul>"},{"location":"lessons/10_testing/integration_testing/#designing-integration-tests","title":"Designing Integration Tests","text":"<ul> <li>Use fixtures to start/stop services (databases, web servers).</li> <li>Seed test data and clean up after tests.</li> </ul>"},{"location":"lessons/10_testing/integration_testing/#example-conceptual","title":"Example (conceptual)","text":"<p>A test might start a test database, run a function that writes data, then query the database to assert the end-to-end behavior.</p>"},{"location":"lessons/10_testing/integration_testing/#gotchas","title":"Gotchas","text":"<ul> <li>Avoid running slow integration tests repeatedly; separate them in CI.</li> <li>Networked services add flakiness \u2014 use local test doubles or containers.</li> </ul>"},{"location":"lessons/10_testing/test_driven_development/","title":"Test-Driven Development (TDD)","text":"<p>TDD is a development workflow where you write tests before implementing functionality.</p>"},{"location":"lessons/10_testing/test_driven_development/#the-cycle","title":"The Cycle","text":"<ol> <li>Red: write a failing test for the desired behavior.</li> <li>Green: implement the minimal code to pass the test.</li> <li>Refactor: clean up while keeping tests green.</li> </ol>"},{"location":"lessons/10_testing/test_driven_development/#benefits-and-trade-offs","title":"Benefits and Trade-offs","text":"<ul> <li>Encourages small incremental design and good test coverage.</li> <li>Can slow initial development and may encourage over-testing internal details.</li> </ul>"},{"location":"lessons/10_testing/test_driven_development/#example-outline","title":"Example (outline)","text":"<ul> <li>Write <code>assert add([1,2]) == 3</code> (failing).</li> <li>Implement <code>def add(items): return sum(items)</code>.</li> <li>Refactor to handle edge cases and keep tests green.</li> </ul>"},{"location":"lessons/10_testing/unit_testing/","title":"Unit Testing","text":"<p>Unit tests check small units of code in isolation. They should be fast and deterministic.</p>"},{"location":"lessons/10_testing/unit_testing/#principles","title":"Principles","text":"<ul> <li>Test one behavior per test.</li> <li>Arrange, Act, Assert structure.</li> <li>Use fixtures to set up and tear down repeated state.</li> </ul>"},{"location":"lessons/10_testing/unit_testing/#example-pytest","title":"Example (pytest)","text":"<pre><code># test_math.py\ndef add(a, b):\n    return a + b\n\ndef test_add():\n    assert add(1, 2) == 3\n</code></pre> <p>Run with:</p> <pre><code>pytest -q\n</code></pre>"},{"location":"lessons/10_testing/unit_testing/#gotchas","title":"Gotchas","text":"<ul> <li>Tests that depend on external services are brittle (use mocks).</li> <li>Flaky tests (time-dependent, order-dependent) reduce confidence.</li> </ul>"},{"location":"lessons/11_advanced_topics/concurrency/","title":"Concurrency","text":"<p>Concurrency lets your program do multiple things at once. Common models include threads, processes, and async I/O.</p>"},{"location":"lessons/11_advanced_topics/concurrency/#threads-vs-processes-vs-async","title":"Threads vs Processes vs Async","text":"<ul> <li>Threads share memory within a process; use locks to synchronize access.</li> <li>Processes have separate memory; communication uses IPC.</li> <li>Async uses an event loop and cooperative multitasking (async/await).</li> </ul>"},{"location":"lessons/11_advanced_topics/concurrency/#race-conditions-and-synchronization","title":"Race Conditions and Synchronization","text":"<p>Protect shared state with locks or use message-passing to avoid shared mutable state.</p>"},{"location":"lessons/11_advanced_topics/concurrency/#example-python-sketch","title":"Example (Python sketch)","text":"<pre><code>import threading\n\ncounter = 0\nlock = threading.Lock()\n\ndef worker():\n    global counter\n    for _ in range(1000):\n        with lock:\n            counter += 1\n</code></pre>"},{"location":"lessons/11_advanced_topics/functional_programming/","title":"Functional Programming","text":"<p>Functional programming (FP) emphasizes pure functions, immutability, and higher-order functions.</p>"},{"location":"lessons/11_advanced_topics/functional_programming/#core-ideas","title":"Core Ideas","text":"<ul> <li>Pure functions: no side effects, same output for same input.</li> <li>Immutability: prefer creating new values instead of mutating.</li> <li>Higher-order functions: functions that accept or return functions.</li> </ul>"},{"location":"lessons/11_advanced_topics/functional_programming/#examples-python","title":"Examples (Python)","text":"<pre><code># map/filter/reduce\nnums = [1, 2, 3]\ndoubled = list(map(lambda x: x*2, nums))\nfiltered = list(filter(lambda x: x % 2 == 1, nums))\n</code></pre>"},{"location":"lessons/11_advanced_topics/functional_programming/#when-to-use-fp","title":"When to Use FP","text":"<p>FP makes reasoning about code easier and is useful for parallelism, but sometimes imperative code is clearer for simple tasks.</p>"},{"location":"lessons/11_advanced_topics/memory_management/","title":"Memory Management","text":"<p>Understanding how programs allocate and free memory helps avoid leaks and reduce peak usage.</p>"},{"location":"lessons/11_advanced_topics/memory_management/#allocation-and-garbage-collection","title":"Allocation and Garbage Collection","text":"<p>High-level languages often provide automatic memory management (garbage collection). In Python, reference counting and a cyclic GC are used.</p>"},{"location":"lessons/11_advanced_topics/memory_management/#profiling-memory","title":"Profiling Memory","text":"<p>Use tools like <code>tracemalloc</code> or external profilers to find memory hotspots.</p> <pre><code>import tracemalloc\ntracemalloc.start()\n# run workload\nprint(tracemalloc.get_traced_memory())\n</code></pre>"},{"location":"lessons/11_advanced_topics/memory_management/#common-sources-of-leaks","title":"Common Sources of Leaks","text":"<ul> <li>Long-lived caches holding references</li> <li>Global variables</li> <li>Detached cycles not reclaimed until GC runs</li> </ul>"},{"location":"lessons/11_advanced_topics/recursion/","title":"Recursion","text":"<p>Recursion is when a function calls itself to solve smaller instances of the same problem.</p>"},{"location":"lessons/11_advanced_topics/recursion/#basics-and-base-case","title":"Basics and Base Case","text":"<p>Every recursive function needs a base case to stop recursion.</p> <pre><code>def factorial(n):\n    if n &lt;= 1:\n        return 1\n    return n * factorial(n - 1)\n</code></pre>"},{"location":"lessons/11_advanced_topics/recursion/#patterns","title":"Patterns","text":"<ul> <li>Divide-and-conquer (merge sort)</li> <li>Tree recursion (traversing tree structures)</li> </ul>"},{"location":"lessons/11_advanced_topics/recursion/#limits-and-tail-recursion","title":"Limits and Tail Recursion","text":"<p>Python has a recursion depth limit; tail-call optimization is not performed by CPython.</p>"},{"location":"lessons/1_data_types/booleans/","title":"Boolean Data Types","text":"<p>Boolean data types represent one of two possible values: <code>true</code> or <code>false</code>. They are  commonly used in programming and logic to indicate the truthiness of a statement or condition. Booleans are essential for determing the sequence of execution in  programming, allowing for decisions to be made based on certain criteria.</p> PythonMATLAB <pre><code>is_raining = True\nhas_umbrella = False\n</code></pre> <pre><code>isRaining = true;\nhasUmbrella = false;\n</code></pre>"},{"location":"lessons/1_data_types/fundamentals/","title":"Fundamentals of Data Types","text":"<p>Data types are a fundamental concept in programming that define the kind of data a variable can hold. They determine how data is stored, manipulated, and interpreted  by  the computer. Bits and bytes are the basic units of data storage in computer systems. A bit is the smallest unit of data, representing a binary value of 0 or 1. A byte consists of 8 bits and can represent 256 different values (2^8). Data types  are built upon these basic units to represent more complex information.</p> <p></p>"},{"location":"lessons/1_data_types/numerics/","title":"Numeric Data Types","text":"<p>Numeric data types are used to represent numbers in programming. They can be broadly  categorized into two main types: integers and floating-point numbers.</p>"},{"location":"lessons/1_data_types/numerics/#integer-types","title":"Integer Types","text":"<p>Integer types represent whole numbers without any fractional or decimal component.</p> <p>They can be further divided into two categories:</p>"},{"location":"lessons/1_data_types/numerics/#signed-integers","title":"Signed Integers:","text":"<p>Signed integers can represent both positive and negative values.</p> <ul> <li><code>int8</code>: 8-bit signed integer (-128 to 127)</li> <li><code>int16</code>: 16-bit signed integer (-32,768 to 32,767)</li> <li><code>int32</code>: 32-bit signed integer (-2,147,483,648 to 2,147,483,647)</li> <li><code>int64</code>: 64-bit signed integer (-large number to large number)</li> </ul> PythonMatlab <pre><code># Standard Library\npython_integer = 10          # signed int\n\n# Numpy\nimport numpy as np\n\na = np.int8(15)  # 8-bit signed integer\nb = np.int16(15) # 16-bit signed integer\nc = np.int32(15) # 32-bit signed integer\nd = np.int64(15) # 64-bit signed integer\ne = np.intp(15) # platform-dependent signed integer\n</code></pre> <pre><code>a = int8(15);    % 8-bit signed integer\nb = int16(15);   % 16-bit signed integer\nc = int32(15);   % 32-bit signed integer\nd = int64(15);   % 64-bit signed integer\n</code></pre>"},{"location":"lessons/1_data_types/numerics/#unsigned-integers","title":"Unsigned Integers","text":"<p>Unsigned integers can only represent non-negative values. Examples include:</p> <ul> <li><code>uint8</code>: 8-bit unsigned integer (0 to 255)</li> <li><code>uint16</code>: 16-bit unsigned integer (0 to 65,535)</li> <li><code>uint32</code>: 32-bit unsigned integer (0 to 4,294,967,295)</li> <li><code>uint64</code>: 64-bit unsigned integer (0 to large number)</li> </ul> PythonMatlab <pre><code># Numpy\nimport numpy as np\n\nf = np.uint8(15)  # 8-bit unsigned integer\ng = np.uint16(15) # 16-bit unsigned integer\nh = np.uint32(15) # 32-bit unsigned integer\ni = np.uint64(15) # 64-bit unsigned integer\n</code></pre> <pre><code>e = uint8(15);   % 8-bit unsigned integer\nf = uint16(15);  % 16-bit unsigned integer\ng = uint32(15);  % 32-bit unsigned integer\nh = uint64(15);  % 64-bit unsigned integer\n</code></pre>"},{"location":"lessons/1_data_types/numerics/#floating-point-types","title":"Floating-Point Types","text":"<p>Floating-point types are used to represent real numbers that have a fractional component.</p> <ul> <li>float16: 16-bit floating-point number (half precision)</li> <li>float32: 32-bit floating-point number (single precision)</li> <li>float64: 64-bit floating-point number (double precision)</li> </ul> PythonMatlab <pre><code>python_float = 3.14        # float\n\n# Numpy\nimport numpy as np\n\nj = np.float16(3.14) # 16-bit floating-point number\nk = np.float32(3.14) # 32-bit floating-point number\nl = np.float64(3.14) # 64-bit floating-point number\n</code></pre> <pre><code>i = single(3.14); % 32-bit floating-point number\nj = double(3.14); % 64-bit floating-point number\n</code></pre>"},{"location":"lessons/1_data_types/numerics/#casting-between-numeric-types","title":"Casting Between Numeric Types","text":"<p>Casting refers to the conversion of one numeric type to another. This is often necessary when performing operations that involve different numeric types. Most programming languages provide built-in functions to facilitate type casting. It is important to  be aware of potential data loss when casting from a higher precision type to a lower precision type.</p> PythonMatlab <pre><code>import numpy as np\n\n# Casting from float to int\nfloat_num = 9.99\nint_num = int(float_num)  # Standard Library\n\n# Numpy casting\na = np.float32(9.99)\nb = a.astype(np.int32)  # Cast to 32-bit integer\n</code></pre> <pre><code>float_num = 9.99;\nint_num = int32(float_num); % Cast to 32-bit integer\n</code></pre>"},{"location":"lessons/1_data_types/numerics/#choosing-the-right-numeric-type","title":"Choosing the Right Numeric Type","text":"<p>When choosing a numeric type, consider the following factors: - Range: Ensure the type can accommodate the expected range of values. - Precision: Choose a type that provides sufficient precision for calculations. - Memory Usage: Consider the memory constraints of your application. - Performance: Some operations may be faster with certain numeric types.</p>"},{"location":"lessons/1_data_types/numerics/#gotchas","title":"Gotcha's","text":"<ul> <li>Be cautious of overflow and underflow when working with fixed-size integer types.</li> <li>Floating-point arithmetic can introduce rounding errors; be mindful when comparing   floating-point numbers to determine if they are identical.</li> <li>When casting a float to an int, not all langauge will follow the same rounding rules.   Always check the documentation for the specific behavior in your programming language.</li> </ul>"},{"location":"lessons/1_data_types/text/","title":"Textual Data Types","text":"<p>Textual data types are used to represent and manipulate text-based information.  In  programming, text is typically represented using strings, which are sequences of characters. Textual data types are essential for handling user input,  displaying  messages, and processing natural language.</p> PythonMATLAB <pre><code>greeting = \"Hello, World!\"\ng = chr(65)  # Character 'A'\n</code></pre> <pre><code>greeting = 'Hello, World!';\ng = char(65); % Character 'A'\n</code></pre>"},{"location":"lessons/2_expressions/comparisons/","title":"Comparisons","text":"<p>Comparisons (also called relational operators) let programs decide how values relate to each other. They produce boolean results (true/false) and are the basic building blocks for conditionals and filters.</p> <p>Common comparison operators:</p> <ul> <li><code>==</code>  equal to</li> <li><code>!=</code> or <code>~=</code> not equal to (Matlab uses <code>~=</code>)</li> <li><code>&lt;</code>   less than</li> <li><code>&gt;</code>   greater than</li> <li><code>&lt;=</code>  less than or equal to</li> <li><code>&gt;=</code>  greater than or equal to</li> <li>'is'  identity comparison (Python only)</li> <li>'is not'  identity negation (Python only)</li> <li>'in'  membership test (Python only)</li> <li> <p>':=' assignment (not a comparison, but often confused with <code>==</code>)</p> </li> <li> <p>Comparison</p> </li> <li>Purpose: compare two values and produce a boolean result.</li> <li>Examples: <code>==</code>, <code>!=</code> (or <code>~=</code>), <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>.</li> <li>Notes: comparison operators are used in conditionals and filtering.</li> </ul> PythonMatlab <pre><code># Basic comparisons\na = 5\nb = 3\nprint(a == b)  # False\nprint(a != b)  # True\nprint(a &gt; b)   # True\n\n# Chained comparisons\nx = 4\nprint(1 &lt; x &lt;= 10)  # True (evaluates as 1 &lt; x and x &lt;= 10)\n\n# 'is' checks identity, not equality\ns1 = \"hello\"\ns2 = \"hello\"\nprint(s1 == s2)  # True (same contents)\nprint(s1 is s2)  # May be True or False depending on interning (identity)\n\n# Comparing different types can be surprising\nprint(0 == False)    # True (bool is a subclass of int)\nprint([] == False)   # False\n</code></pre> <pre><code>% Basic comparisons\na = 5;\nb = 3;\ndisp(a == b)   % 0 (false)\ndisp(a ~= b)   % 1 (true)\ndisp(a &gt; b)    % 1 (true)\n\n% Element-wise comparisons for arrays\nA = [1, 2, 3];\nB = [1, 0, 4];\nC = A &gt; B;     % [0 1 0]\n\n% Range checks\nx = 4;\ndisp(1 &lt; x &amp;&amp; x &lt;= 10) % true (logical short-circuit with scalars)\n</code></pre>"},{"location":"lessons/2_expressions/comparisons/#gotchas","title":"Gotchas","text":"<ol> <li>Floating-point comparisons: exact equality is fragile (e.g., <code>0.1 + 0.2 == 0.3</code>     may be False). Prefer a tolerance (abs(a-b) &lt; eps).</li> <li>Identity vs equality: <code>is</code> (Python) checks object identity, not value equality.</li> <li>Chained comparisons: are evaluated left-to-right but are concise and useful;     beware when mixing side-effecting expressions.</li> <li>Type coercion: some languages coerce types during comparison (Python treats     bools as ints; other languages differ).</li> <li>Array comparisons: in Matlab and NumPy, comparisons on arrays produce     element-wise boolean arrays \u2014 make sure to reduce with <code>all()</code>/<code>any()</code> when needed.</li> </ol>"},{"location":"lessons/2_expressions/fundamentals/","title":"Expressions","text":"<p>Recall, from the introduction lesson, that a program is made up of instructions  (operators, functions, methods) that manipulate variables &amp; data structures stored  in memory and some logic that determines the order of execution (control flow). These  instructions can be broadly categorized into expressions and statements.</p> <code>1. Expressions</code> An expression is a piece of code that the programming language evaluates to  produce a value. Expressions are the building blocks of programs: they combine values, variables, operators, and function calls to compute results that programs use or store. <code>2. Statements</code> A statement is a complete instruction that performs an action, such as assigning  values to variables or controlling the flow of execution. Statements may contain  expressions, but their primary purpose is to do something rather than to produce  a value. <p>Expressions vs. Statements</p> <p>Expressions are something, statements do something.</p> <p>For a deeper discussion of statements (assignment, control-flow statements, scope,  and side effects),  see the companion lesson: <code>../.. /lessons/3_control_flow/statements.md</code>.</p>"},{"location":"lessons/2_expressions/operators/","title":"Operators","text":"<p>Operators combine values and produce new values. They are the core of expressions and come in several categories: arithmetic, comparison, logical, bitwise, and assignment.</p> <p>Understanding operator precedence (which operation runs first) and associativity  (left/right) helps avoid subtle bugs; use parentheses to make intent explicit.</p>"},{"location":"lessons/2_expressions/operators/#operator-categories","title":"Operator categories","text":"<p>Below are common categories of operators you will encounter. Each category describes what the operators do and gives short examples \u2014 language syntax varies, but the concepts are the same.</p> <ul> <li>Basic math (arithmetic)</li> <li>Purpose: perform numeric calculations (addition, subtraction, multiplication,     division, modulus, exponentiation).</li> <li>Examples: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code> (floor division, language-specific), <code>%</code>, <code>**</code>.</li> <li> <p>Notes: some languages distinguish integer vs floating division; some have     special operators for matrix or element-wise operations.</p> </li> <li> <p>Assignment</p> </li> <li>Purpose: store a value into a variable.</li> <li> <p>Examples: <code>=</code> (simple assignment), and related forms below.</p> </li> <li> <p>Augmented assignment</p> </li> <li>Purpose: combine an operation with assignment for conciseness and sometimes     performance.</li> <li> <p>Examples: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>//=</code>, <code>%=</code>. Equivalent to <code>x = x + y</code> but     shorter and, in some languages, may avoid extra temporaries.</p> </li> <li> <p>Logical</p> </li> <li>Purpose: combine or invert boolean values.</li> <li>Examples: <code>and</code>, <code>or</code>, <code>not</code> (language-specific), sometimes <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>.</li> <li> <p>Notes: logical operators may short-circuit (skip evaluating the right-hand     side) in many languages \u2014 this is important when the right-hand side has     side effects or expensive computations.</p> </li> <li> <p>Bitwise</p> </li> <li>Purpose: operate on individual bits of integer values.</li> <li>Examples: <code>&amp;</code> (and), <code>|</code> (or), <code>^</code> (xor), <code>~</code> (not), <code>&lt;&lt;</code> (left shift), <code>&gt;&gt;</code> (right shift).</li> <li> <p>Notes: bitwise operators behave differently from logical operators and do not     short-circuit; they are useful in low-level programming and some numeric tricks.</p> </li> <li> <p>Membership and identity (where applicable)</p> </li> <li>Purpose: test whether a value is contained in a collection (membership) or whether     two references are the same object (identity).</li> <li> <p>Examples: <code>in</code>, <code>not in</code>, <code>is</code>, <code>is not</code> (Python); other languages have     similar constructs or library functions.</p> </li> <li> <p>Precedence and associativity</p> </li> <li>Purpose: determine the order in which operators are applied when several appear     in one expression.</li> <li>Notes: multiplication has higher precedence than addition in most languages     (<code>1 + 2 * 3 == 7</code>), and parentheses <code>()</code> override precedence. When in doubt,     use parentheses to make intent explicit.</li> </ul> PythonMatlab <pre><code># Arithmetic\na = 7\nb = 3\nprint(a + b)   # 10\nprint(a - b)   # 4\nprint(a * b)   # 21\nprint(a / b)   # 2.333...\nprint(a // b)  # 2 (floor division)\nprint(a % b)   # 1 (remainder)\nprint(a ** b)  # 343 (exponent)\n\n# Augmented assignment\nx = 2\nx += 3  # x == 5\n\n# Logical operators\nprint(True and False)  # False\nprint(True or False)   # True\nprint(not True)        # False\n\n# Bitwise (integers)\nprint(5 &amp; 3)  # 1\nprint(5 | 3)  # 7\nprint(5 ^ 3)  # 6\n\n# Precedence example\nprint(1 + 2 * 3)       # 7\nprint((1 + 2) * 3)     # 9\n</code></pre> <pre><code>% Arithmetic and matrix operations\na = 7;\nb = 3;\ndisp(a + b)   % 10\ndisp(a - b)   % 4\ndisp(a * b)   % 21 (matrix multiply for scalars is same)\ndisp(a / b)   % 7/3\ndisp(a ^ b)   % 343 (power)\n\n% Element-wise operators (use . for element-wise)\nA = [1 2; 3 4];\nB = [2 0; 1 2];\nC = A .* B;  % element-wise multiply\nD = A * B;   % matrix multiply\n\n% Logical operators\ndisp(true &amp;&amp; false)\ndisp(true || false)\ndisp(~true)\n\n% Precedence: use parentheses to be clear\n</code></pre>"},{"location":"lessons/2_expressions/operators/#gotchas","title":"Gotchas","text":"<ol> <li>Division differences: Python <code>/</code> always produces a float; <code>//</code> is floor     division.  Matlab <code>/</code> and <code>\\</code> relate to matrix right- and left-division  (they     are not simple scalar integer divisions).</li> <li>Element-wise vs matrix operations: Matlab distinguishes <code>*</code> (matrix multiply)     from <code>.*</code> (element-wise). A common bug is mixing them when operating on arrays.</li> <li>Short-circuiting: <code>and</code>/<code>or</code> in Python short-circuit (right-hand side may not     be  evaluated); bitwise operators <code>&amp;</code>/<code>|</code> do not short-circuit and operate on     bits or element-wise booleans (NumPy).</li> <li>Operator precedence can be surprising; parentheses improve readability and     correctness.</li> </ol>"},{"location":"lessons/2_expressions/variables/","title":"Variables","text":"<p>Variables are names that refer to values. Assigning a variable binds a name to a  value; later references to the name use the bound value. Variables make programs  readable and let us reuse computed results. Variables can be reassigned to new  values,  and in both Python &amp; Matlab, they can refer to values of different types  over time (dynamic typing).</p> Variables vs. Values <p>Let's return to our cooking analogy: variables are like labels on bowls, and values are the dough inside.</p> <ul> <li>Putting dough into a bowl = assigning a value to a variable.</li> <li>Moving the label to a different bowl = rebinding the variable to a new value.</li> <li>Scooping dough into a new bowl = \"shallow\" copying a value.</li> <li>Replicating the dough in a new bowl = \"deep\" copying a value.</li> <li>Two labels on the same bowl = two variables referencing the same mutable  object = changing the dough through one label changes both variables.</li> </ul> PythonMatlab <pre><code># Simple assignment\nx = 10\n\n# Rebinding and dynamic typing\nx = \"now a string\"\n\n# Multiple assignment / unpacking\na, b = 1, 2\na, b = b, a  # swap without a temp variable\n\n# Type hints (optional)\ny: int = 5\n</code></pre> <pre><code>% Assignment\nx = 10;\n\n% Rebinding and dynamic typing\nx = 'now a string';\n\n% Multiple assignment is usually done element-wise or via arrays\na = 1; b = 2;\n</code></pre>"},{"location":"lessons/2_expressions/variables/#gotchas","title":"Gotchas","text":"<ol> <li>Case-Sensitivity: Variables names are case-sensitive and must start with      a letter or underscore</li> <li>Reserved keywords: Special reserved words (e.g., <code>if</code>, <code>for</code>, <code>while</code>) cannot be     used as variable names.</li> <li>Shadowing: Don't use names that shadow other things (e.g., <code>list</code>, <code>str</code>,     <code>sum</code>). You may no longer be able to access them!</li> <li>Mutability: Always assume variables are mutable by default; unexpected sharing     happens when multiple variables refer to the same object!</li> </ol>"},{"location":"lessons/3_control_flow/conditionals/","title":"Conditionals","text":"<p>Conditionals let programs choose different actions depending on values or conditions. They are the foundation of branching logic: <code>if</code> a condition holds, do something; <code>else</code> do something else.</p> <p>Conditionals use boolean expressions (see the Comparisons lesson) and short-circuiting logic.</p> PythonMatlab <pre><code># Simple if\nscore = 75\nif score &gt;= 60:\n    print(\"pass\")\n\n# if / else\nx = 7\nif x % 2 == 0:\n    print(\"even\")\nelse:\n    print(\"odd\")\n\n# if / elif / else chain\nn = -1\nif n &lt; 0:\n    print(\"negative\")\nelif n == 0:\n    print(\"zero\")\nelse:\n    print(\"positive\")\n\n# Truthiness\nitems = []\nif items:\n    print(\"has items\")\nelse:\n    print(\"empty\")\n\n# Ternary expression\nresult = \"yes\" if score &gt; 50 else \"no\"\n</code></pre> <pre><code>% Simple if\nscore = 75;\nif score &gt;= 60\n  disp('pass')\nend\n\n% if / else\nx = 7;\nif mod(x,2) == 0\n  disp('even')\nelse\n  disp('odd')\nend\n\n% if / elseif / else\nn = -1;\nif n &lt; 0\n  disp('negative')\nelseif n == 0\n  disp('zero')\nelse\n  disp('positive')\nend\n\n% Check for empty arrays\nA = [];\nif ~isempty(A)\n  disp('has items')\nelse\n  disp('empty')\nend\n</code></pre>"},{"location":"lessons/3_control_flow/conditionals/#gotchas","title":"Gotchas","text":"<ul> <li>Python uses indentation to delimit blocks; Matlab uses <code>end</code>. Mixing styles causes syntax errors.</li> <li>In Matlab <code>=</code> is assignment and <code>==</code> is comparison; accidentally using <code>=</code> in a conditional will error or assign.</li> <li>Truthiness: empty containers are Falsey in Python, and <code>isempty</code> is the usual check in Matlab.</li> <li>Order matters in <code>elif</code>/<code>elseif</code> chains \u2014 the first matching branch runs.</li> </ul>"},{"location":"lessons/3_control_flow/iteration/","title":"Iteration","text":"<p>Iteration (loops) allow a program to repeat work: processing items, accumulating results, or running until a condition changes. Use loops for repeated tasks; prefer vectorized operations (Matlab, NumPy) when they are simpler and faster.</p> PythonMatlab <pre><code># for over a list\nnames = [\"Alice\", \"Bob\", \"Carol\"]\nfor name in names:\n    print(name)\n\n# range-based loop\nfor i in range(5):  # 0..4\n    print(i)\n\n# enumerate to get index and value\nfor i, v in enumerate(names):\n    print(i, v)\n\n# while loop\nn = 5\nwhile n &gt; 0:\n    print(n)\n    n -= 1\n\n# break and continue\nfor x in [1, -1, 3, 0]:\n    if x &lt; 0:\n        continue\n    if x == 0:\n        break\n    print(x)\n</code></pre> <pre><code>% for loop with range (1-based)\nfor i = 1:5\n  disp(i)\nend\n\n% for over array (column iteration)\nA = [10 20 30];\nfor v = A\n  disp(v)\nend\n\n% while loop\nn = 5;\nwhile n &gt; 0\n  disp(n)\n  n = n - 1;\nend\n\n% break and continue\nfor x = [1 -1 3 0]\n  if x &lt; 0\n    continue\n  end\n  if x == 0\n    break\n  end\n  disp(x)\nend\n\n% Vectorized alternative example (prefer when possible)\nvals = [1 2 3 4]; weights = [0.1 0.2 0.3 0.4];\ns = sum(vals .* weights);  % no explicit loop\n</code></pre>"},{"location":"lessons/3_control_flow/iteration/#gotchas","title":"Gotchas","text":"<ul> <li>Indexing origin: Python is 0-based; Matlab is 1-based. Off-by-one errors are common.</li> <li>Modifying a list/array while iterating it can lead to skipped elements or unexpected behavior.</li> <li><code>while</code> loops can become infinite; ensure the loop condition will eventually be false.</li> <li>Prefer vectorized operations in Matlab and NumPy for performance and clarity when operating on arrays.</li> </ul>"},{"location":"lessons/3_control_flow/matching/","title":"Matching","text":"<p>Matching (switch/case, <code>match</code>/<code>case</code>) provides a concise way to dispatch behavior based on value or structure. It is often clearer than long <code>if</code>/<code>elif</code>/<code>elseif</code> chains when handling many distinct cases, and modern languages (Python 3.10+) support structural pattern matching.</p> PythonMatlab <pre><code># Literal matching (Python 3.10+)\ncommand = \"start\"\nmatch command:\n    case \"start\":\n        print(\"starting\")\n    case \"stop\":\n        print(\"stopping\")\n    case _:\n        print(\"unknown\")\n\n# Matching tuples\npoint = (0, 0)\nmatch point:\n    case (0, 0):\n        print(\"origin\")\n    case (x, y):\n        print(f\"point at {x},{y}\")\n\n# Matching mapping-like structures\ndata = {\"type\": \"user\", \"id\": 42}\nmatch data:\n    case {\"type\": \"user\", \"id\": uid}:\n        print(f\"user {uid}\")\n    case _:\n        print(\"other\")\n</code></pre> <pre><code>% switch/case for value matching\ncmd = 'start';\nswitch cmd\n  case 'start'\n    disp('starting')\n  case 'stop'\n    disp('stopping')\n  otherwise\n    disp('unknown')\nend\n\n% Matlab does not have structural pattern matching; use isequal or conditional checks\npoint = [0 0];\nif isequal(point, [0 0])\n  disp('origin')\nelseif numel(point) == 2\n  x = point(1); y = point(2);\n  disp([\"point at \" num2str(x) \",\" num2str(y)])\nend\n\n% Dispatch using a map of function handles\nhandlers = containers.Map({'start','stop'},{@()disp('start'), @()disp('stop')});\nkey = 'start';\nif isKey(handlers, key)\n  handlers(key)();\nelse\n  disp('unknown')\nend\n</code></pre>"},{"location":"lessons/3_control_flow/matching/#gotchas","title":"Gotchas","text":"<ul> <li>Python <code>match</code> is syntax introduced in 3.10 and uses pattern semantics (not simple equality): ensure your interpreter supports it.</li> <li>Patterns can capture variables; be careful about accidental captures.</li> <li>Matlab <code>switch</code> tests values for equality; it is not structural matching. For complex patterns, combine <code>if</code>/<code>elseif</code> with <code>isequal</code> or use a dispatch table.</li> <li>Overusing <code>match</code>/<code>switch</code> for complex logic can make code harder to test \u2014 prefer small functions per case.</li> </ul>"},{"location":"lessons/3_control_flow/statements/","title":"Statements","text":"<p>A statement tells the computer to do something. Where an expression evaluates to a value, a statement performs an action: it assigns a value, controls the flow of execution, or produces an observable effect (like printing to the screen).</p> <p>Although many languages keep a strict distinction between expressions and statements, some languages blur the line (for example, C-family assignment returns a value; Python's \"walrus\" operator <code>:=</code> introduces expression-style assignment). This lesson focuses on the statement-level constructs that structure programs.</p>"},{"location":"lessons/3_control_flow/statements/#why-statements-matter","title":"Why statements matter","text":"<ul> <li>Statements organize program behavior: they change state, make decisions, and repeat work.</li> <li>Understanding statements is essential for controlling program flow, debugging, and reasoning about scope and side effects.</li> <li>Many bugs arise from incorrect ordering of statements or misunderstanding the effects of mutation.</li> </ul>"},{"location":"lessons/3_control_flow/statements/#simple-statements","title":"Simple statements","text":"<p>Simple statements are single-line units that perform a small action.</p> <ul> <li>Expression statements: an expression used as a statement (e.g., a function call whose return value is ignored).</li> <li>Assignment: binds a value to a name. In many beginner-focused materials this is written as <code>name = expression</code>.</li> <li>Augmented assignment: shortcuts combining an operation and assignment (<code>x += 1</code>, <code>total *= factor</code>).</li> <li>Multiple-assignment / tuple-unpacking: assign several names at once (<code>a, b = b, a</code>).</li> </ul> <p>Examples (Python)</p> Python <pre><code># expression statement (call for side effect)\nprint(\"Hello\")\n\n# assignment\nx = 10\n\n# augmented assignment\nx += 5  # equivalent to x = x + 5\n\n# multiple assignment / swap\na, b = 1, 2\na, b = b, a  # swap values\n</code></pre>"},{"location":"lessons/3_control_flow/statements/#compound-statements-and-blocks","title":"Compound statements and blocks","text":"<p>Compound statements contain other statements and typically control the flow of execution.</p> <ul> <li>Conditionals: <code>if</code>, <code>elif</code>, <code>else</code> choose which statements run.</li> <li>Loops: <code>for</code> and <code>while</code> repeat statements until a condition changes.</li> <li>Exception handling: <code>try</code>, <code>except</code>, <code>finally</code> manage errors and cleanup.</li> <li>Context managers: <code>with</code> (in languages that support them) create scoped behavior.</li> </ul> <p>Blocks group statements together. In some languages blocks are delimited with braces (<code>{ ... }</code>); in Python they are created by indentation.</p> <p>Examples (Python)</p> Python <pre><code># conditional\nif x &gt; 0:\n    print(\"positive\")\nelse:\n    print(\"non-positive\")\n\n# loop\nfor i in range(3):\n    print(i)\n\n# try/except\ntry:\n    risky()\nexcept ValueError as e:\n    handle(e)\nfinally:\n    cleanup()\n</code></pre>"},{"location":"lessons/3_control_flow/statements/#control-flow-keywords","title":"Control-flow keywords","text":"<ul> <li><code>return</code> \u2014 exit a function and optionally provide a value.</li> <li><code>break</code> \u2014 exit the nearest loop early.</li> <li><code>continue</code> \u2014 skip to the next iteration of the loop.</li> <li><code>pass</code> \u2014 a no-op statement used as a placeholder.</li> <li><code>import</code> / <code>from</code> \u2014 bring modules and names into scope (statement form in many languages).</li> </ul> <p>Examples (Python)</p> Python <pre><code>def find_first_positive(items):\n    for x in items:\n        if x &gt; 0:\n            return x\n    return None\n\nfor n in numbers:\n    if should_skip(n):\n        continue\n    if is_done(n):\n        break\n</code></pre>"},{"location":"lessons/3_control_flow/statements/#assignment-details-and-variable-lifetime","title":"Assignment details and variable lifetime","text":"<p>Assignment creates or updates a binding between a name and a value. Important points:</p> <ul> <li>Assignment does not \"copy\" semantics for immutable types; it binds a name to a value (the implementation details vary by language).</li> <li>Scope determines where a binding is visible: local, nonlocal/enclosing, module, and global scopes are common.</li> <li>Lifetime is the period during which a binding remains valid; garbage-collected languages free memory when no reachable references remain.</li> </ul> <p>Examples (Python)</p> Python <pre><code># local binding\ndef f():\n    x = 1  # x is local to f\n\n# modifying an outer binding (explicit in Python)\ndef outer():\n    x = 0\n    def inner():\n        nonlocal x\n        x += 1\n    inner()\n</code></pre>"},{"location":"lessons/3_control_flow/statements/#statements-vs-expressions-across-languages","title":"Statements vs expressions across languages","text":"<ul> <li>Expression-oriented languages (e.g., many functional languages) favor expressions everywhere \u2014 control-flow constructs return values.</li> <li>Statement-oriented languages (e.g., classical Python, pre-walrus) separate actions (statements) from value-producing expressions.</li> <li>Many modern languages mix both approaches; understanding which constructs yield values helps when porting code or reading other languages.</li> </ul> <p>Quick note: In Python the assignment statement does not itself yield a value. The walrus operator <code>:=</code> allows assignment as part of an expression, which can be convenient but should be used judiciously to keep code readable.</p>"},{"location":"lessons/3_control_flow/statements/#side-effects-and-best-practices","title":"Side effects and best practices","text":"<ul> <li>Statements are the usual place where side effects happen (mutating data, performing I/O, changing global state).</li> <li>Favor small functions that minimize side effects; keep pure computations as expressions where possible \u2014 this makes reasoning and testing easier.</li> <li>Keep statements simple and clear: one primary action per statement is a helpful guideline.</li> </ul>"},{"location":"lessons/3_control_flow/statements/#common-pitfalls","title":"Common pitfalls","text":"<ul> <li>Assuming assignments to an object mutate the outer variable in every language.</li> <li>Relying on implicit fall-through or unspecified evaluation order.</li> <li>Overusing expression-style assignment (e.g., chaining assignments that hide intent).</li> </ul>"},{"location":"lessons/3_control_flow/statements/#examples-and-patterns","title":"Examples and patterns","text":"Python <pre><code># swapping values without temporary variable\na, b = b, a\n\n# accumulate in a loop\ntotal = 0\nfor x in items:\n    total += x\n\n# guard clause for clarity\nif not prepared():\n    return  # early exit keeps the happy path unindented\n</code></pre>"},{"location":"lessons/3_control_flow/statements/#links-and-further-reading","title":"Links and further reading","text":"<ul> <li>See <code>../../lessons/2_expressions/fundamentals.md</code> for the expressions overview (short contrast between expressions and statements).</li> <li>See <code>../../lessons/2_expressions/variables.md</code> for basic variable usage and literals.</li> <li>Related: <code>../../lessons/2_expressions/operators.md</code> for operator precedence and operator behavior.</li> </ul>"},{"location":"lessons/4_functions/defining_functions/","title":"Defining Functions","text":"<p>Functions package behavior into reusable units with a name, parameters, and a body. They improve readability, avoid repetition, and make testing simpler.</p> PythonMatlab <pre><code>def greet(name):\n    return f\"Hello, {name}\"\n\n# Multiple returns\ndef divmod_pair(a, b):\n    return a // b, a % b\nq, r = divmod_pair(7, 3)\n\n# Docstring\ndef add(a, b):\n    \"\"\"Return the sum of a and b.\"\"\"\n    return a + b\n</code></pre> <pre><code>% Define a function in its own file (greet.m) or as a local function\nfunction s = greet(name)\n  s = [\"Hello, \" name];\nend\n\n% Multiple outputs\nfunction [q, r] = divmod_pair(a, b)\n  q = floor(a / b);\n  r = mod(a, b);\nend\n</code></pre>"},{"location":"lessons/4_functions/defining_functions/#gotchas","title":"Gotchas","text":"<ul> <li>In Python, functions are first-class values (they can be passed around and assigned).</li> <li>Matlab functions usually live in their own files or as local/subfunctions; be aware of file naming conventions.</li> <li>Keep functions small and focused \u2014 prefer many small functions to one large function.</li> </ul>"},{"location":"lessons/4_functions/parameters_and_arguments/","title":"Parameters and Arguments","text":"<p>Parameters name the inputs a function accepts; arguments are the actual values passed. Understanding positional, keyword (named), default, and variadic parameters makes APIs flexible.</p> PythonMatlab <pre><code>def f(a, b=2, *args, **kwargs):\n    print(a, b, args, kwargs)\n\n# Call examples\nf(1)\nf(1, 3)\nf(1, 3, 4, 5, x=10)\n\n# Keyword-only parameters (Python 3)\ndef g(a, *, verbose=False):\n    if verbose:\n        print(a)\n</code></pre> <pre><code>% Matlab functions accept positional arguments; use varargin for variable inputs\nfunction out = f(a, b, varargin)\n  disp(a);\n  if ~isempty(varargin)\n    disp(varargin{1})\n  end\nend\n\n% Name-value pairs are often handled via parser or struct\n</code></pre>"},{"location":"lessons/4_functions/parameters_and_arguments/#gotchas","title":"Gotchas","text":"<ul> <li>Default parameter values in Python are evaluated once; avoid mutable defaults.</li> <li>Matlab does not have keyword arguments by default; name-value pairs are passed as varargin and parsed manually.</li> <li>Be explicit about parameter types and document expected shapes for array inputs.</li> </ul>"},{"location":"lessons/4_functions/return_values/","title":"Return Values","text":"<p>Functions can return values to their caller. Understanding how and when to return values (vs. mutating inputs or printing) is key to writing reusable code.</p> PythonMatlab <pre><code>def add(a, b):\n    return a + b\n\n# Multiple returns (tuples)\ndef divmod_pair(a, b):\n    return a // b, a % b\n\nq, r = divmod_pair(7, 3)\n\n# Returning None implicitly\ndef noisy(a):\n    print(a)\nx = noisy(5)  # x is None\n</code></pre> <pre><code>% Single return\nfunction s = greet(name)\n  s = [\"Hello, \" name];\nend\n\n% Multiple outputs\nfunction [q, r] = divmod_pair(a, b)\n  q = floor(a / b);\n  r = mod(a, b);\nend\n\n% If a function has no outputs, calling it returns nothing\n</code></pre>"},{"location":"lessons/4_functions/return_values/#gotchas","title":"Gotchas","text":"<ul> <li>Returning mutable objects vs copying: returning a reference to a mutable object may allow callers to mutate internal state.</li> <li>Implicit <code>None</code> (Python) or no output (Matlab) can confuse callers expecting a value \u2014 document return types.</li> <li>Multiple outputs (Matlab) vs tuple unpacking (Python) have slightly different calling conventions.</li> </ul>"},{"location":"lessons/4_functions/scope_and_lifetime/","title":"Scope and Lifetime","text":"<p>Scope determines where a name is visible; lifetime determines how long a value exists. Understanding local vs global scope, closures, and lifetime (especially for resources) is important.</p> PythonMatlab <pre><code>x = 10  # global\ndef f():\n    y = 5  # local\n    print(x, y)\n\n# Global modification\ndef g():\n    global x\n    x = x + 1\n\n# Closure\ndef make_adder(n):\n    def add(x):\n        return x + n\n    return add\nadd3 = make_adder(3)\nprint(add3(4))  # 7\n</code></pre> <pre><code>% Globals (use sparingly)\nglobal x\nx = 10;\n\nfunction show()\n  global x\n  disp(x)\nend\n\n% Nested functions capture variables from outer scope\nfunction f = make_adder(n)\n  f = @() n + 1; % simple closure example\nend\n</code></pre>"},{"location":"lessons/4_functions/scope_and_lifetime/#gotchas","title":"Gotchas","text":"<ul> <li>Overusing globals leads to fragile code and hard-to-track bugs.</li> <li>Mutable objects referenced in closures can produce surprising results if mutated after closure creation.</li> <li>Resource lifetime: open files/sockets should be closed; prefer context managers (Python <code>with</code>) or <code>onCleanup</code> in Matlab.</li> </ul>"},{"location":"lessons/4_functions/scripts_vs_functions/","title":"Scripts vs Functions","text":"<p>Scripts are sequences of statements executed top-to-bottom; functions encapsulate behavior with parameters and (optionally) return values. Prefer functions for reusable logic; use scripts for simple one-off tasks or as program entrypoints.</p> PythonMatlab <pre><code># script: top-level code executed on import/run\nprint('this runs when the file is executed')\n\n# function: encapsulated behavior\ndef main():\n    print('main called')\n\nif __name__ == '__main__':\n    main()\n</code></pre> <pre><code>% script.m contains top-level statements and affects the base workspace\na = 1;\ndisp(a)\n\n% function files define functions and have their own local workspace\nfunction out = myfunc(x)\n  out = x + 1;\nend\n</code></pre>"},{"location":"lessons/4_functions/scripts_vs_functions/#gotchas","title":"Gotchas","text":"<ul> <li>In Python, top-level code runs on import; guard execution with <code>if __name__ == '__main__'</code>.</li> <li>Matlab scripts operate in the base workspace and can unintentionally overwrite variables; prefer functions for reusable code.</li> <li>Use functions for unit-testable logic and scripts for orchestration.</li> </ul>"},{"location":"lessons/5_data_structures/arrays/","title":"Arrays","text":"<p>Arrays are collections of items of the same type, commonly used for numerical computation. In Python, the <code>list</code> is general-purpose; <code>numpy</code> arrays provide efficient numeric arrays. Matlab uses arrays (matrices) as its core data structure.</p> PythonMatlab <pre><code># Python lists (general)\nlst = [1, 2, 3]\n\n# Numpy arrays (numeric)\nimport numpy as np\na = np.array([1, 2, 3])\nb = a * 2  # element-wise\n\n# Shape and indexing\na.shape\na[0]\n</code></pre> <pre><code>% Create arrays/matrices\nA = [1 2 3];       % row vector\nM = [1 2; 3 4];    % 2x2 matrix\n\n% Element-wise operations\nB = A .* 2;\n\n% Size and indexing\ns = size(M);\nv = M(1,2);\n</code></pre>"},{"location":"lessons/5_data_structures/arrays/#gotchas","title":"Gotchas","text":"<ul> <li>Numpy arrays enforce homogeneous types; mixing types will coerce to a common type.</li> <li>Matlab is 1-based indexing; Python/NumPy are 0-based.</li> <li>Be careful with shapes (row vs column) when multiplying matrices.</li> </ul>"},{"location":"lessons/5_data_structures/hash_map/","title":"Hash Map (Dictionaries)","text":"<p>Hash maps (associative arrays, dictionaries) store key-value pairs and provide fast lookup by key. They are ideal for mapping names to values, counting, and grouping data.</p> PythonMatlab <pre><code># Creation\nd = {'a': 1, 'b': 2}\nempty = {}\n\n# Access and set\nd['c'] = 3\nv = d.get('x', 0)  # default if missing\n\n# Iteration\nfor k, val in d.items():\n    print(k, val)\n\n# Counting\nfrom collections import Counter\ncnt = Counter(['a','b','a'])\n</code></pre> <pre><code>% containers.Map as a hash map\nkeys = {'a','b'};\nvals = {1,2};\nm = containers.Map(keys, vals);\n\n% Access\nm('c') = 3; % add\nif isKey(m, 'x')\n  v = m('x');\nelse\n  v = 0;\nend\n</code></pre>"},{"location":"lessons/5_data_structures/hash_map/#gotchas","title":"Gotchas","text":"<ul> <li>Keys must be hashable (immutable) in Python; lists cannot be keys but tuples can.</li> <li>Order: Python 3.7+ preserves insertion order for dicts, but don't rely on it for logic unless intended.</li> <li>Matlab <code>containers.Map</code> requires matching key/value cell arrays for construction and may be slower than native arrays for numeric-heavy code.</li> </ul>"},{"location":"lessons/5_data_structures/lists/","title":"Lists","text":"<p>Lists (also called arrays or sequences in some languages) are ordered collections of values. They are useful when you need an indexed, iterable container that can grow or shrink.</p> PythonMatlab <pre><code># Creation\nlst = [1, 2, 3]\nempty = []\n\n# Indexing and slicing\nfirst = lst[0]\ntail = lst[1:]\n\n# Mutating\nlst.append(4)\nlst[1] = 20\n\n# Comprehensions\nsquares = [x*x for x in range(5)]\n\n# Iteration\nfor i, v in enumerate(lst):\n    print(i, v)\n</code></pre> <pre><code>% Row vector as a list\nlst = [1 2 3];\nempty = [];\n\n% Indexing (1-based)\nfirst = lst(1);\ntail = lst(2:end);\n\n% Grow by concatenation\nlst = [lst 4];\n\n% Iterate\nfor i = 1:numel(lst)\n  disp([i lst(i)])\nend\n</code></pre>"},{"location":"lessons/5_data_structures/lists/#gotchas","title":"Gotchas","text":"<ul> <li>Lists are mutable in Python; assigning one list to another name creates a shared reference.</li> <li>Slicing in Python creates a shallow copy; modifying the slice doesn't change the original list.</li> <li>Matlab vectors are 1-based and are arrays by default; use cell arrays <code>{}</code> for heterogeneous collections.</li> <li>Avoid using mutable objects as default function arguments in Python.</li> </ul>"},{"location":"lessons/5_data_structures/sets/","title":"Sets","text":"<p>Sets represent unordered collections of unique elements. They are useful for deduplication, membership tests, and set operations (union, intersection, difference).</p> PythonMatlab <pre><code>s = {1, 2, 3}\ns.add(4)\ns.discard(2)\nprint(3 in s)  # membership\n\n# Set operations\na = {1,2,3}\nb = {3,4,5}\nprint(a &amp; b)  # intersection\nprint(a | b)  # union\nprint(a - b)  # difference\n</code></pre> <pre><code>% Unique and set operations\nA = [1 2 3 2];\nU = unique(A);        % [1 2 3]\nB = [3 4 5];\ninter = intersect(U, B);\nuni = union(U, B);\ndiff = setdiff(U, B);\n</code></pre>"},{"location":"lessons/5_data_structures/sets/#gotchas","title":"Gotchas","text":"<ul> <li>Sets are unordered; you cannot rely on iteration order.</li> <li>Elements must be hashable/eligible for set membership (immutable) in Python.</li> <li>Matlab set functions work on arrays and return sorted unique results.</li> </ul>"},{"location":"lessons/5_data_structures/tuples/","title":"Tuples","text":"<p>Tuples are ordered, immutable collections. They are useful when you want a fixed sequence that should not change (for example, coordinates or records).</p> PythonMatlab <pre><code># Creation\nt = (1, 2, 3)\nsingle = (1,)  # trailing comma for single-element tuple\n\n# Indexing\nfirst = t[0]\n\n# Immutable: methods that would mutate return new values\ns = (1, 2) + (3,)\n\n# Useful for unpacking\nx, y, z = t\n</code></pre> <pre><code>% MATLAB does not have a tuple type; use fixed-size vectors or cell arrays for heterogenous data\nt = [1 2 3];  % numeric tuple-like\nc = {\"a\", 1, true};  % heterogeneous cell array\n</code></pre>"},{"location":"lessons/5_data_structures/tuples/#gotchas","title":"Gotchas","text":"<ul> <li>Tuples are immutable in Python; attempting to assign to an index raises an error.</li> <li>Use tuples as keys in dictionaries when you need composite keys.</li> <li>In Matlab, cell arrays can hold heterogeneous types similar to tuples but use different indexing (<code>{}</code> vs <code>()</code>).</li> </ul>"},{"location":"lessons/6_classes/attributes_and_methods/","title":"Attributes and Methods","text":"<p>Attributes store object state; methods define behavior. Use instance attributes for per-object state and class attributes for shared data.</p> PythonMatlab <pre><code>class Counter:\n    step = 1  # class attribute\n\n    def __init__(self, start=0):\n        self.value = start  # instance attribute\n\n    def inc(self):\n        self.value += self.step\n\nc = Counter()\nc.inc()\nprint(c.value)\n</code></pre> <pre><code>classdef Counter\n  properties\n    value = 0;\n  end\n  properties (Constant)\n    step = 1;\n  end\n  methods\n    function obj = inc(obj)\n      obj.value = obj.value + obj.step;\n    end\n  end\nend\n</code></pre>"},{"location":"lessons/6_classes/attributes_and_methods/#gotchas","title":"Gotchas","text":"<ul> <li>Access class attributes via the class name or <code>self.__class__</code> to avoid accidental shadowing.</li> <li>In Matlab, class properties have attributes (like <code>Constant</code>) that change their behavior.</li> <li>Avoid large mutable class-level defaults unless intentionally shared.</li> </ul>"},{"location":"lessons/6_classes/defining_classes/","title":"Defining Classes","text":"<p>Classes group data and behavior into a single blueprint. Instances (objects) are created from classes and hold their own state. Object-oriented design helps model real-world concepts and encapsulate related functions.</p> PythonMatlab <pre><code>class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n\n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n</code></pre> <pre><code>classdef Point\n  properties\n    x\n    y\n  end\n  methods\n    function obj = Point(x, y)\n      obj.x = x;\n      obj.y = y;\n    end\n    function obj = move(obj, dx, dy)\n      obj.x = obj.x + dx;\n      obj.y = obj.y + dy;\n    end\n  end\nend\n</code></pre>"},{"location":"lessons/6_classes/defining_classes/#gotchas","title":"Gotchas","text":"<ul> <li>Remember to initialize instance state (Python <code>__init__</code>, Matlab constructor).</li> <li>Be explicit about <code>self</code> / returning modified objects (Matlab methods often return the modified object for value-like semantics).</li> <li>Keep classes focused; don't cram unrelated behavior into a single class.</li> </ul>"},{"location":"lessons/6_classes/encapsulation/","title":"Encapsulation","text":"<p>Encapsulation hides internal details and exposes a minimal interface. It prevents external code from depending on internal representation and helps maintain invariants.</p> PythonMatlab <pre><code>class BankAccount:\n    def __init__(self, balance=0):\n        self._balance = balance  # underscore signals \"private\"\n\n    def deposit(self, amount):\n        if amount &gt; 0:\n            self._balance += amount\n\n    def balance(self):\n        return self._balance\n</code></pre> <pre><code>classdef BankAccount\n  properties (Access = private)\n    balance = 0;\n  end\n  methods\n    function obj = deposit(obj, amount)\n      if amount &gt; 0\n        obj.balance = obj.balance + amount;\n      end\n    end\n    function b = getBalance(obj)\n      b = obj.balance;\n    end\n  end\nend\n</code></pre>"},{"location":"lessons/6_classes/encapsulation/#gotchas","title":"Gotchas","text":"<ul> <li>Python's privacy is by convention (<code>_</code> vs <code>__</code> name mangling) \u2014 it does not enforce access.</li> <li>Use property getters/setters when you need to validate assignments or compute values on access.</li> <li>In Matlab, <code>Access = private</code> enforces visibility rules more strictly.</li> </ul>"},{"location":"lessons/6_classes/instantiation/","title":"Instantiation","text":"<p>Instantiation creates objects from classes. Understand constructors, default values, and how multiple instances maintain independent state.</p> PythonMatlab <pre><code>class Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\np1 = Point(1,2)\np2 = Point()\np1.x = 10  # p2.x remains 0\n</code></pre> <pre><code>p1 = Point(1,2);\np2 = Point();\np1.x = 10; % p2.x remains default\n</code></pre>"},{"location":"lessons/6_classes/instantiation/#gotchas","title":"Gotchas","text":"<ul> <li>Beware of shared mutable defaults if class-level objects are used as defaults.</li> <li>Constructors should validate inputs and establish invariants.</li> <li>In some languages, object creation may be expensive; consider factory functions or pooling for hot paths.</li> </ul>"},{"location":"lessons/7_modules/importing/","title":"Importing","text":"<p>Modules let you organize code into files; packages group modules. Importing makes symbols from modules available in your current namespace.</p> PythonMatlab <pre><code># import module\nimport math\nprint(math.sqrt(2))\n\n# import symbol\nfrom math import sqrt\nprint(sqrt(2))\n\n# alias\nimport numpy as np\n</code></pre> <pre><code>% MATLAB uses the path and packages via +foldername\n% Add folder to path or put on MATLAB path\naddpath('mypkg')\n% Call functions in folder\nresult = myfunc(1);\n</code></pre>"},{"location":"lessons/7_modules/importing/#module-layout-package","title":"Module layout (package)","text":"<ul> <li>mypkg/</li> <li>init.py</li> <li>mod.py</li> </ul>"},{"location":"lessons/7_modules/importing/#gotchas","title":"Gotchas","text":"<ul> <li>Python: circular imports can cause runtime errors; structure modules to avoid mutual dependencies.</li> <li>Use absolute imports in packages to be clear; relative imports are useful for internal modules.</li> <li>Matlab package folders (starting with <code>+</code>) create namespaces; ensure path visibility.</li> </ul>"},{"location":"lessons/7_modules/libraries_and_packages/","title":"Libraries and Packages","text":"<p>Libraries provide reusable functionality; packages bundle related modules and subpackages. Use package managers to install third-party libraries and organize your code into packages.</p> PythonMatlab <pre><code># Use pip to install a package\n# pip install requests\n\nimport requests\nr = requests.get('https://example.com')\nprint(r.status_code)\n</code></pre> <pre><code>% Add library folders to MATLAB path or install toolbox\naddpath('mylib')\nhelp mylib\n</code></pre>"},{"location":"lessons/7_modules/libraries_and_packages/#example-package-layout","title":"Example package layout","text":"<p>mypkg/   init.py   utils.py   core.py</p>"},{"location":"lessons/7_modules/libraries_and_packages/#gotchas","title":"Gotchas","text":"<ul> <li>Keep dependencies minimal and document them in a <code>requirements.txt</code> or <code>pyproject.toml</code>.</li> <li>Semantic versioning: use pinned versions for reproducible environments where necessary.</li> <li>For Matlab, prefer toolboxes or documented add-ons for portability.</li> </ul>"},{"location":"lessons/8_git/branching_and_merging/","title":"Branching and Merging","text":"<p>Branches let you develop features in isolation and keep the main line of development stable. Merging integrates changes from one branch into another.</p>"},{"location":"lessons/8_git/branching_and_merging/#branching","title":"Branching","text":"<p>Create a new branch and switch to it:</p> <pre><code>git checkout -b feature/my-feature\n</code></pre> <p>List branches (current branch marked with *):</p> <pre><code>git branch\n</code></pre> <p>Delete a branch locally:</p> <pre><code>git branch -d feature/my-feature\n</code></pre>"},{"location":"lessons/8_git/branching_and_merging/#merging","title":"Merging","text":"<p>To merge a feature branch into <code>main</code>:</p> <pre><code>git checkout main\ngit merge feature/my-feature\n</code></pre> <p>If Git cannot automatically combine changes you'll get a merge conflict that must be resolved by editing the conflicting files, staging, and committing.</p>"},{"location":"lessons/8_git/branching_and_merging/#resolving-conflicts","title":"Resolving Conflicts","text":"<ul> <li>Git marks conflicts with &lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, &gt;&gt;&gt;&gt;&gt;&gt;&gt; markers inside files.</li> <li>Edit to choose or combine changes, then run <code>git add &lt;file&gt;</code> and <code>git commit</code> to finish.</li> </ul>"},{"location":"lessons/8_git/branching_and_merging/#rebase-vs-merge","title":"Rebase vs Merge","text":"<p>Rebasing rewrites commits to create a linear history:</p> <pre><code>git checkout feature/my-feature\ngit rebase main\n</code></pre> <p>Use rebase to keep history linear for private branches; avoid rebasing public/shared branches.</p>"},{"location":"lessons/8_git/version_control_basics/","title":"Version Control Basics","text":"<p>Version control systems record changes to files over time so you can recall specific versions later. Git is a distributed version control system commonly used for source code.</p>"},{"location":"lessons/8_git/version_control_basics/#core-concepts","title":"Core Concepts","text":"<ul> <li>Repository (repo): a directory tracked by Git.</li> <li>Commit: a snapshot of changes with a message and metadata.</li> <li>Branch: a named pointer to a commit, used to isolate work.</li> <li>Remote: a hosted copy of a repo (for example, GitHub).</li> </ul>"},{"location":"lessons/8_git/version_control_basics/#minimal-workflow","title":"Minimal Workflow","text":"<p>A typical local workflow looks like:</p> <pre><code># initialize a repo\ngit init\n# stage and commit changes\ngit add .\ngit commit -m \"Initial commit\"\n# add remote and push\ngit remote add origin &lt;url&gt;\ngit push -u origin main\n</code></pre>"},{"location":"lessons/8_git/version_control_basics/#best-practices","title":"Best Practices","text":"<ul> <li>Commit small, logical changes with clear messages.</li> <li>Use branches for features and bugfixes.</li> <li>Pull regularly to integrate remote changes before pushing.</li> </ul>"},{"location":"lessons/8_git/version_control_basics/#gotchas","title":"Gotchas","text":"<ul> <li>Commits are local until pushed to a remote.</li> <li>Rewriting published history (git rebase --force) can disrupt collaborators.</li> </ul>"},{"location":"lessons/9_debugging/debugging_tools/","title":"Debugging Tools","text":"<p>There are many tools that help you inspect program state and find bugs: interactive debuggers, logging, and IDE features.</p>"},{"location":"lessons/9_debugging/debugging_tools/#interactive-debuggers","title":"Interactive Debuggers","text":"<p>Set breakpoints, step into functions, and inspect variables.</p> <p>Python example:</p> <pre><code>import pdb\npdb.set_trace()\n# or run: python -m pdb your_script.py\n</code></pre>"},{"location":"lessons/9_debugging/debugging_tools/#logging-vs-print","title":"Logging vs Print","text":"<p>Logging is more flexible than print-debugging: you can set levels and direct output to files.</p> <pre><code>import logging\nlogging.basicConfig(level=logging.INFO)\nlogging.info(\"starting\")\n</code></pre>"},{"location":"lessons/9_debugging/debugging_tools/#ide-and-browser-tools","title":"IDE and Browser Tools","text":"<ul> <li>IDEs (PyCharm, VS Code) provide visual breakpoints and variable watches.</li> <li>Browser devtools help debug front-end JavaScript.</li> </ul>"},{"location":"lessons/9_debugging/error_types/","title":"Error Types","text":"<p>Errors come in several flavors. Understanding their categories helps diagnose problems quickly.</p>"},{"location":"lessons/9_debugging/error_types/#categories","title":"Categories","text":"<ul> <li>Syntax Errors: mistakes in the code's structure that prevent parsing.</li> <li>Runtime Errors: occur while the program is running (exceptions).</li> <li>Semantic Errors (Logic Errors): program runs but produces incorrect results.</li> </ul>"},{"location":"lessons/9_debugging/error_types/#examples-python","title":"Examples (Python)","text":"<pre><code># SyntaxError: missing colon\n# def foo()\n#     pass\n\n# Runtime / TypeError example\nx = 'a'\n# x + 1  # TypeError: can only concatenate str (not \"int\") to str\n\n# Semantic error example\ndef average(items):\n    return sum(items) / len(items)  # incorrect if len(items) == 0\n</code></pre>"},{"location":"lessons/9_debugging/error_types/#using-tracebacks","title":"Using Tracebacks","text":"<p>Tracebacks show the call stack and the error message. Read from the bottom up to find the origin.</p>"},{"location":"lessons/9_debugging/error_types/#gotchas","title":"Gotchas","text":"<ul> <li>Catching too broad an exception (e.g., bare <code>except:</code>) can hide bugs.</li> </ul>"},{"location":"lessons/9_debugging/exception_and_error_handling/","title":"Exception &amp; Error Handling","text":"<p>Handling exceptions lets your program respond to unexpected conditions without crashing.</p>"},{"location":"lessons/9_debugging/exception_and_error_handling/#try-except-finally","title":"try / except / finally","text":"<pre><code>try:\n    value = int(user_input)\nexcept ValueError:\n    print(\"Invalid number\")\nelse:\n    print(\"Parsed OK\")\nfinally:\n    print(\"Always runs\")\n</code></pre>"},{"location":"lessons/9_debugging/exception_and_error_handling/#raising-exceptions","title":"Raising Exceptions","text":"<p>Use <code>raise</code> to signal an error:</p> <pre><code>if value &lt; 0:\n    raise ValueError(\"value must be non-negative\")\n</code></pre>"},{"location":"lessons/9_debugging/exception_and_error_handling/#custom-exceptions","title":"Custom Exceptions","text":"<p>Create a specific exception type for domain errors:</p> <pre><code>class ValidationError(Exception):\n    pass\n\nraise ValidationError(\"bad input\")\n</code></pre>"},{"location":"lessons/9_debugging/exception_and_error_handling/#best-practices","title":"Best Practices","text":"<ul> <li>Catch specific exception types.</li> <li>Log errors with context.</li> <li>Use <code>finally</code> or context managers for cleanup.</li> </ul>"},{"location":"lessons/9_debugging/linting_and_static_analysis/","title":"Linting and Static Analysis","text":"<p>Linters and static analyzers help detect style issues, bugs, and anti-patterns before runtime.</p>"},{"location":"lessons/9_debugging/linting_and_static_analysis/#what-they-do","title":"What They Do","text":"<ul> <li>Enforce style conventions (PEP8 for Python).</li> <li>Detect possible errors (unused variables, unreachable code).</li> <li>Suggest improvements (complexity, typing).</li> </ul>"},{"location":"lessons/9_debugging/linting_and_static_analysis/#popular-tools","title":"Popular Tools","text":"<ul> <li>Python: <code>flake8</code>, <code>pylint</code>, <code>mypy</code> (static typing)</li> <li>JavaScript: <code>eslint</code></li> </ul> <p>Run a simple check with flake8:</p> <pre><code>flake8 path/to/file.py\n</code></pre>"},{"location":"lessons/9_debugging/linting_and_static_analysis/#interpreting-warnings","title":"Interpreting Warnings","text":"<p>Not all warnings are errors \u2014 assess severity and fix relevant issues. Configure tool rules to match project preferences.</p>"},{"location":"lessons/introduction/languages/","title":"Programming Languages","text":"<p>A computer ultimately executes only very simple operations. Humans, by contrast,  think  in rich, ambiguous concepts. Programming languages exist to bridge this gap: they allow humans to express precise procedures in a form that machines can execute.</p> <p>Every programming language is a compromise between various factors, including:</p> <pre><code>- Abstractness: how much detail is hidden from the programmer\n- Readability: how easily humans can understand the code\n- Expressiveness: how easily we can represent complex ideas\n- Performance: how efficiently the computer can execute the program\n- Portability: how easily code can run on different hardware and operating systems\n</code></pre> <p>Understanding languages conceptually matters more than mastering any single one.  From the low-level assembly languages that interact directly with hardware to high-level  languages that abstract away fine details, all languages share common principles. The goal for any programmer is to understand these principles so they can use the  appropriate tools for the task at hand (instead of being married to a single language).</p>"},{"location":"lessons/introduction/languages/#the-hierarchy-of-languages","title":"The Hierarchy of Languages","text":"<p>It is useful to think of languages as forming a hierarchy, ordered by how close they  are to natural human language (i.e., their level of abstraction).  </p>"},{"location":"lessons/introduction/languages/#natural-language","title":"Natural Language","text":"<p>Natural language is flexible, contextual, and deeply ambiguous. This makes it ideal  for communication between humans and unsuitable for execution by machines.</p> example <p>Consider the instruction:</p> <p>\u201cPlot the data and clean it up.\u201d</p> <p>A human scientist can interpret this. A computer cannot.</p>"},{"location":"lessons/introduction/languages/#high-level-programming-languages","title":"High-Level Programming Languages","text":"<p>High-level languages allow you to express ideas in a compact, readable form while hiding many implementation details. These languages are designed to help you think more about what you want to do, and less about how the hardware does it.</p> <p>Python and MATLAB fall squarely in this category. Although they differ syntactically, they share similar conceptual foundations.</p>"},{"location":"lessons/introduction/languages/#low-level-programming-languages","title":"Low-Level Programming Languages","text":"<p>Low-level languages sit closer to the hardware. This additional control comes at the  cost of verbosity and cognitive load. Low-level languages are essential when performance, timing, or hardware interaction is critical, but they are rarely the  best place to start reasoning about a scientific problem.</p>"},{"location":"lessons/introduction/languages/#machine-code","title":"Machine Code","text":"<p>At the bottom of the hierarchy is machine code: sequences of binary instructions executed directly by the processor. Machine code is maximally precise and maximally unreadable. Every program, regardless of the language it is written in, is  eventually translated into machine code before execution.</p>"},{"location":"lessons/introduction/programming_matters/","title":"Programming Matters","text":""},{"location":"lessons/introduction/what_is_programming/","title":"What is Programming?","text":"<p>Programming is the process of creating instructions that a computer can understand  and execute. These instructions, known as code, are written in programming languages  such as Python, Java, or C++. Programming allows us to create software applications,  websites, games, and more by providing the computer with a set of rules to follow.</p> <p>Cumulatively, these instructions comprise a procedure. These instructions  operate on information stored in memory and update that information step by step. This is not fundamentally different from a laboratory protocol or an analysis methods  section. The difference is that a program must be complete enough that no judgment  calls are left to the executor.</p> <p>Traditionally, one can think of programming as consisting of two primary components:</p> <code>1. Algorithms</code> Recipes in natural or psuedo-language for solving specific problems <code>2. Implementations</code> The translation of algorithms machine-readable instructions Baking Cookies <p>Thinking of programming like making chocolate chip cookies. Our algorithm might be our common-sense recipe for making cookies: putting dough on the tray in the  shape of cookies, adding chocolate chips, and baking them in the oven. Meanwhile, our implementation is the exact, specific steps we take using our own kitchen:  setting the oven to 350 degrees, baking for 12 minutes, and using a specific type  of chocolate chips.</p> <p>In practice, programming involves three key components:</p> <code>1. Variables &amp; Data Structures</code> How relevant information is stored and organized. <code>2. Control Flow</code> The logic that determines the order in which specific instructions are executed. <code>3. Operators, Functions, &amp; Methods</code> Reusable instructions that perform specific tasks. Baking Cookies <p>Continuing with our cookie-making analogy, variables and data structures are like  the ingredients we use (flour, sugar, chocolate chips) and how we organize them  (in bowls, measuring cups). Control flow is like the sequence of steps we  follow in the recipe (1. mixing ingredients, 2. shaping cookies, 3. baking). Operators, functions, and methods are like specific tools &amp; utensils we use  (our oven, cookie cutters, mixers).</p>"},{"location":"lessons/introduction/what_is_programming/#programming-is-best-learned-by-doing","title":"Programming is best learned by doing.","text":"<p>The best way to learn programming is by writing code. The central intellectual  challenge of programming is translating informal reasoning and problem-solving into formal logic and instructions that a computer can execute. This requires practice and experience implementing your own solutions to problems. Much like one can't become a  good writer by only reading books, one can't become a good programmer by following  examples and reading written code. You must write your own code, make mistakes, and  learn your own individual process of problem-solving.</p> <p>Programming is not about memorizing syntax or specific commands. Instead, it is  about developing a mindset and approach to problem-solving that can be applied  across many different programming languages and contexts. While memorizing syntax  can be helpful and make you more efficient in the extreme short-term, you will be in a much better position if you focus on understanding the underlying concepts and logic of programming. </p>"},{"location":"lessons/introduction/what_is_programming/#if-you-can-understand-the-principles-of-programming","title":"If you can understand the principles of programming...","text":"<ol> <li>You can learn new languages in days instead of months</li> <li>You can design your own solutions to problems instead of relying on copy-pasting</li> <li>You will be able to anticipate and debug errors more effectively</li> <li>You won't be thrown off by the small changes languages introduce year to year</li> <li>And most importantly, you won't become frustrated or lost when you re-encounter your     own code months or years later (especially after taking a long break from     programming to write or conduct experiments).</li> </ol>"},{"location":"lessons/preface/docs/","title":"Documentation","text":"<p>Documentation is a critical aspect of software development that is often overlooked by beginners and those in a hurry. It's extremely important to document your code and  projects thoroughly to ensure that others (and your future self) can understand and  use your work.</p>"},{"location":"lessons/preface/ides/","title":"Integrated Development Environments","text":"<p>An Integrated Development Environment (IDE) is a software application that provides a comprehensive application for software development. An IDE typically includes a  code editor, build automation tools, and a debugger. Some IDEs also offer features like  code completion, syntax highlighting, static analysis, and version control integration.</p>"},{"location":"lessons/preface/ides/#python","title":"Python","text":"<p>Popular IDEs for python development include:</p> <ol> <li>VS Code: A lightweight, open-source IDE developed by Microsoft      that supports a wide range of programming languages through extensions.</li> <li>Visual Studio: A full-featured IDE also developed by Microsoft,         primarily for .NET and C++ development (but supports many other languages).</li> <li>PyCharm: An IDE developed by JetBrains specifically for Python development,         offering advanced features like code analysis and web development support.</li> <li>Jupyter: An open-source web application that allows you to create and share          documents that contain live code, equations, visualizations, and narrative text.</li> <li>Spyder: An open-source IDE oriented towards data analysis and visualization.</li> <li>Notepad++: A text editor often used for coding with support for syntax        highlighting. Generally used by the elderly or for quick edits.</li> </ol> <p>Tip</p> <p>Visual Studio and PyCharm are generally preferred by professional developers  due to their robust feature sets and support for large-scale projects.</p>"},{"location":"lessons/preface/ides/#matlab","title":"MATLAB","text":"<p>MATLAB is shipped with its own built-in IDE, which is tailored for engineering applications (though with limited support for general-purpose programming).</p>"},{"location":"lessons/preface/venv/","title":"Virtual Environments","text":"<p>Virtual environments are a crucial tool in software development that allow you to  create isolated spaces for your projects. This isolation helps manage dependencies and  avoid conflicts between different projects. For example, you might have two projects that require different versions of the same library. You might even have two projects that have different functions with identical names! By using virtual environments,  you can ensure that each project stays self-contained and doesn't interfere with others.</p> <p>Most virtual environments are paired with a package manager, which helps you install,  update, and manage the libraries your project depends on.</p>"},{"location":"lessons/preface/venv/#python","title":"Python","text":"<p>Popular tools for managing virtual environments in Python include:</p> <ul> <li>venv: A built-in module that comes with Python 3. It allows you to create      lightweight virtual environments. It is usually paired with the <code>pip</code> package      manager that comes bundled with Python.</li> <li>pipx: A tool to help you install and run Python applications in isolated      environments. Usually paired with <code>poetry</code> package manager.</li> <li>conda: A cross-platform package manager that also manages virtual environments.     It is popular in data science and scientific computing communities, and for the      sudden changes to the academic and non-profit licensing of their user interface      Anaconda in 2024 (alongside unexpected legal threats to institutions that      continued  to use it). A command-line only implementation miniconda remains      free. Conda manages both packages and environments for multiple programming     languages.</li> <li>uv: An extremely fast, modern tool made by Astral. It is designed to be simple      to use and easy to integrate into existing workflows.</li> </ul> <p>Note</p> <p>I heavily recommend using <code>uv</code> for beginners and experienced developers alike.</p>"},{"location":"lessons/preface/venv/#matlab","title":"MATLAB","text":"<p>MATLAB achieves similar functionality to virtual environments by using a \"path\" system. You can create separate folders for different projects and add or remove these folders from the MATLAB path as needed. This way, you can manage different sets of functions and scripts for each project without conflicts. Unfortunately, this is quite cumbersome and not conducive to good development practices.</p>"}]}